<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMPIOUS.io // ENLIST</title>
    <style>
        /* --- MASTER PALETTE & VARS --- */
        :root {
            /* Colors */
            --void-black: #07080B;
            --moon-ink: #0B0D12;
            --vapor-purple: #6B39FF;
            --toxic-pink: #D73CFF;
            
            /* UI specific vars */
            --cool-white: #DDFBFF;
            --cool-white-dim: rgba(221, 251, 255, 0.75);
            --imperial-cyan: #58E6E0;
            --ritual-red: #FF1F4E;
            --magenta-start: #FF3B7F;
            --magenta-end: #D73CFF;
            --input-radius: 12px;
            
            /* TYPEFACE SPLIT */
            /* 1. Imperial UI (Body, Inputs, Buttons) */
            --font-sans: "Liberation Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
            
            /* 2. Terminal Data (Labels, Micro-copy) */
            --font-mono: "Consolas", "Monaco", monospace;
        }

        * { box-sizing: border-box; }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--void-black);
            overflow: hidden;
            
            /* BODY DEFAULTS TO SANS (Imperial UI) */
            font-family: var(--font-sans);
            
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- BACKGROUND STACK (Z-INDEX 0-4) --- */
        
        canvas#cathedral-deck {
            display: block;
            position: fixed;
            top: 0; left: 0;
            z-index: 0;
        }

        .layer-substrate {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 1;
            background: radial-gradient(circle at center, var(--moon-ink) 0%, var(--void-black) 90%);
            opacity: 0.9; 
        }

        .layer-haze {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 2;
            background: 
                radial-gradient(circle at 0% 0%, rgba(107, 57, 255, 0.04), transparent 40%),
                radial-gradient(circle at 100% 100%, rgba(215, 60, 255, 0.03), transparent 40%);
            mix-blend-mode: screen;
        }

        .layer-phosphor {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 3;
            background: linear-gradient(
                to bottom,
                rgba(255, 255, 255, 0.03),
                rgba(255, 255, 255, 0.03) 50%,
                rgba(0, 0, 0, 0.03) 50%,
                rgba(0, 0, 0, 0.03)
            );
            background-size: 100% 2px;
        }

        .layer-grain {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 4;
            opacity: 0.04; 
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        /* --- FOREGROUND FORM STACK (Z-INDEX 10+) --- */

        .impious-terminal {
            position: relative;
            width: 100%;
            max-width: 420px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            z-index: 10; 
        }

        .brand-title {
            font-family: var(--font-sans); /* Explicitly Sans */
            font-size: clamp(36px, 6vw, 56px);
            font-weight: 700;
            margin: 0 0 10px 0;
            letter-spacing: -0.02em; /* Tighter, more modern */
            color: var(--cool-white);
            text-transform: uppercase;
            position: relative;
            display: inline-block;
        }

        .brand-title::before,
        .brand-title::after {
            content: attr(data-text);
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: transparent; 
        }

        .brand-title::before {
            left: 1px;
            text-shadow: -1px 0 var(--imperial-cyan);
            animation: glitch-anim-1 5s infinite linear alternate-reverse;
        }

        .brand-title::after {
            left: -1px;
            text-shadow: 1px 0 var(--ritual-red);
            animation: glitch-anim-2 4s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim-1 {
            0%, 85% { clip-path: inset(0 0 0 0); }
            90% { clip-path: inset(10% 0 85% 0); }
            95% { clip-path: inset(0 0 0 0); }
            98% { clip-path: inset(65% 0 30% 0); }
            100% { clip-path: inset(0 0 0 0); }
        }

        @keyframes glitch-anim-2 {
            0%, 80% { clip-path: inset(0 0 0 0); }
            85% { clip-path: inset(30% 0 65% 0); }
            90% { clip-path: inset(0 0 0 0); }
            95% { clip-path: inset(80% 0 15% 0); }
            100% { clip-path: inset(0 0 0 0); }
        }

        .tagline {
            font-family: var(--font-sans);
            font-size: clamp(14px, 2vw, 18px);
            font-weight: 400;
            margin: 0 0 32px 0;
            letter-spacing: 0.05em;
            color: var(--cool-white-dim);
        }

        .form-stack {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        input[type="email"] {
            width: 100%;
            height: 52px;
            background: rgba(11, 13, 18, 0.3); 
            border: 1px solid rgba(221, 251, 255, 0.12);
            border-radius: var(--input-radius);
            color: var(--cool-white);
            padding: 0 16px;
            
            /* SANS for readability in the UI */
            font-family: var(--font-sans); 
            font-size: 16px;
            transition: all 0.2s ease;
            outline: none;
            backdrop-filter: blur(4px);
        }

        input[type="email"]::placeholder { color: rgba(221, 251, 255, 0.35); }

        input[type="email"]:focus {
            background: rgba(11, 13, 18, 0.6);
            border-color: rgba(88, 230, 224, 0.8);
            box-shadow: 0 0 15px rgba(88, 230, 224, 0.15);
            caret-color: var(--imperial-cyan);
        }

        button.submit-btn {
            width: 100%;
            height: 52px;
            background: linear-gradient(90deg, var(--magenta-start), var(--magenta-end));
            border: none;
            border-radius: var(--input-radius);
            color: #07080B;
            font-weight: 700;
            font-size: 15px;
            letter-spacing: 0.08em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            margin-top: 4px;
            /* SANS for button command */
            font-family: var(--font-sans); 
        }

        button.submit-btn:hover {
            filter: brightness(1.12);
            box-shadow: 0 0 0 1px rgba(88, 230, 224, 0.4);
        }

        button.submit-btn:active {
            transform: scale(0.99);
            filter: brightness(0.95);
        }

        button.submit-btn.success {
            background: var(--imperial-cyan);
            color: #fff;
            pointer-events: none;
        }

        .micro-trust {
            margin-top: 16px;
            font-size: 12px;
            opacity: 0.5;
            letter-spacing: 0.05em;
            color: var(--cool-white);
            
            /* MONO for tiny technical disclaimer */
            font-family: var(--font-mono);
        }
    </style>
</head>
<body>

    <canvas id="cathedral-deck"></canvas>
    <div class="layer-substrate"></div>
    <div class="layer-haze"></div>
    <div class="layer-phosphor"></div>
    <div class="layer-grain"></div>

    <div class="impious-terminal">
        <h1 class="brand-title" data-text="IMPIOUS.io">IMPIOUS.io</h1>
        <p class="tagline">Don’t look now.</p>

        <form class="form-stack" onsubmit="event.preventDefault(); handleEnlist();">
            <input type="email" id="emailInput" placeholder="signal@source.com" required autocomplete="off">
            <button type="submit" id="submitBtn" class="submit-btn">Enlist</button>
        </form>

        <div class="micro-trust">No spam.</div>
    </div>

    <script>
        // --- FORM HANDLER ---
        function handleEnlist() {
          const input = document.getElementById('emailInput');
          const btn = document.getElementById('submitBtn');
          const email = input.value.trim();

          if (!email || !email.includes('@')) return (input.focus(), input.select());

          btn.innerText = "CONNECTING...";
          btn.disabled = true;

          fetch('/enlist', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email })
          })
          .then(res => {
            if (!res.ok) throw new Error('rejected');
            return res.json();
          })
          .then(() => {
            btn.classList.add('success');
            btn.innerHTML = "REGISTERED &nbsp; ✓";
            input.style.borderColor = "var(--imperial-cyan)";
            
            setTimeout(() => {
              window.location.href = '/watch-out.html';
            }, 600);
          })
          .catch(() => {
            btn.disabled = false;
            btn.innerText = "REJECTED";
            btn.style.background = "var(--ritual-red)";
            input.style.borderColor = "var(--ritual-red)";
            setTimeout(() => {
              btn.innerText = "Enlist";
              btn.style.background = "";
              input.style.borderColor = "";
            }, 2000);
          });
        }

        // --- LATTICE ENGINE ---
        const canvas = document.getElementById('cathedral-deck');
        const ctx = canvas.getContext('2d', { alpha: false }); 

        let width, height;
        let mouse = { x: -5000, y: -5000 };

        const PALETTE = {
            bg: '#07080B',           
            grid: '35, 40, 56',      
            neutral: '26, 30, 39',   
            cyan: { r: 88, g: 230, b: 224 },    
            white: { r: 221, g: 251, b: 255 },  
            magenta: { r: 255, g: 59, b: 127 }, 
            red: { r: 255, g: 31, b: 78 },      
            purple: '107, 57, 255'   
        };

        const CONFIG = {
            grid: {
                spacing: 28,
                radius: 1.1,
                baseAlpha: 0.05,     
                activeAlpha: 0.12,   
                activeRadius: 200
            },
            lattice: {
                nodeCount: 100,
                connectionDist: 130,
                centerSafeZone: 380, 
                mouseRadius: 200
            }
        };

        const random = (min, max) => Math.random() * (max - min) + min;
        const generateID = () => {
            const chars = '0123456789ABCDEF';
            let id = '';
            for (let i = 0; i < 4; i++) id += chars.charAt(Math.floor(Math.random() * chars.length));
            return id;
        };

        function drawGrid() {
            ctx.shadowBlur = 0;
            ctx.fillStyle = PALETTE.bg;
            ctx.fillRect(0, 0, width, height);

            for (let x = CONFIG.grid.spacing / 2; x < width; x += CONFIG.grid.spacing) {
                for (let y = CONFIG.grid.spacing / 2; y < height; y += CONFIG.grid.spacing) {
                    
                    let alpha = CONFIG.grid.baseAlpha;
                    let xOffset = 0, yOffset = 0;

                    const dx = mouse.x - x;
                    const dy = mouse.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < CONFIG.grid.activeRadius) {
                        const pct = 1 - (dist / CONFIG.grid.activeRadius);
                        alpha += (CONFIG.grid.activeAlpha - CONFIG.grid.baseAlpha) * pct;
                        const shift = 1.5 * pct; 
                        xOffset = (dx / dist) * -shift;
                        yOffset = (dy / dist) * -shift;
                    }

                    const relativeY = y / height;
                    let mask = 1.0;
                    if (relativeY < 0.15) mask = relativeY * 6; 
                    else if (relativeY > 0.85) mask = (1 - relativeY) * 6;
                    
                    ctx.fillStyle = `rgba(${PALETTE.grid}, ${alpha * mask})`;
                    ctx.beginPath();
                    ctx.arc(x + xOffset, y + yOffset, CONFIG.grid.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Node {
            constructor(index) {
                this.index = index;
                this.reset();
                this.x = this.baseX;
                this.y = this.baseY;
            }

            reset() {
                if (Math.random() < 0.8) {
                    this.baseX = random(width * 0.15, width * 0.85);
                    this.baseY = random(height * 0.15, height * 0.85);
                } else {
                    this.baseX = random(0, width);
                    this.baseY = random(0, height);
                }

                this.depth = Math.random(); 
                this.id = generateID();
                this.decayed = false; 

                if (this.index % 17 === 0) {
                    this.type = 'SIGIL';
                    this.size = 6; 
                    this.hasLabel = false;
                } else {
                    const roll = Math.random();
                    if (roll < 0.70) {
                        this.type = 'SUBJECT';
                        this.size = random(2.5, 3.5);
                        this.hasLabel = Math.random() < 0.3; 
                    } else if (roll < 0.75) {
                        this.type = 'TRAITOR';
                        this.size = random(3.0, 4.0);
                        this.hasLabel = true; 
                    } else {
                        this.type = 'NEUTRAL';
                        this.size = random(2.0, 2.5);
                        this.hasLabel = false;
                        if (Math.random() < 0.15) this.decayed = true;
                    }
                }

                this.phase = random(0, Math.PI * 2);
                this.period = random(0.0003, 0.0008); 
                this.ampX = random(10, 20);
                this.ampY = random(10, 20);
                this.pulsePhase = random(0, Math.PI * 2);
            }

            update(time) {
                const driftX = Math.sin(time * this.period + this.phase) * this.ampX;
                const driftY = Math.cos(time * this.period + this.phase) * this.ampY;

                const parallaxMult = this.depth * 1.5; 
                const mouseXClamp = Math.max(0, Math.min(width, mouse.x));
                const mouseYClamp = Math.max(0, Math.min(height, mouse.y));
                const leanX = ((width/2 - mouseXClamp) / width) * 30 * parallaxMult;
                const leanY = ((height/2 - mouseYClamp) / height) * 30 * parallaxMult;

                const dx = mouse.x - (this.baseX + driftX + leanX);
                const dy = mouse.y - (this.baseY + driftY + leanY);
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                let localX = 0, localY = 0;
                this.activeScale = 1.0;

                if (dist < CONFIG.lattice.mouseRadius) {
                    const intensity = 1 - (dist / CONFIG.lattice.mouseRadius);
                    const push = 10 * intensity; 
                    localX = -(dx / dist) * push;
                    localY = -(dy / dist) * push;
                    this.activeScale = 1.0 + (intensity * 0.4);
                }

                if (this.type === 'TRAITOR') {
                    localX += random(-0.5, 0.5);
                    localY += random(-0.5, 0.5);
                }

                this.x = this.baseX + driftX + leanX + localX;
                this.y = this.baseY + driftY + leanY + localY;
            }

            draw(time) {
                const centerX = width / 2;
                const centerY = height / 2;
                const centerDist = Math.hypot(this.x - centerX, this.y - centerY);
                let readabilityAlpha = 1.0;
                
                if (centerDist < CONFIG.lattice.centerSafeZone) {
                    readabilityAlpha = Math.max(0.15, centerDist / CONFIG.lattice.centerSafeZone);
                }

                if (this.type === 'SIGIL') {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    const alpha = 0.08 * readabilityAlpha; 
                    ctx.strokeStyle = `rgba(${PALETTE.purple}, ${alpha})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.size);
                    ctx.lineTo(this.x + this.size, this.y);
                    ctx.lineTo(this.x, this.y + this.size);
                    ctx.lineTo(this.x - this.size, this.y);
                    ctx.closePath();
                    ctx.stroke();
                    return;
                }

                if (this.type === 'NEUTRAL') {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                    let baseAlpha = this.decayed ? 0.1 : 0.5; 
                    let alpha = (baseAlpha + (this.depth * 0.1)) * readabilityAlpha;
                    ctx.fillStyle = `rgba(${PALETTE.neutral}, ${alpha})`;
                    ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                    return;
                }

                if (this.type === 'SUBJECT') {
                    let alpha = (0.8 + (this.depth * 0.2)) * readabilityAlpha;
                    const s = this.size * this.activeScale;
                    const c = PALETTE.cyan;
                    ctx.shadowBlur = 12 * this.activeScale;
                    ctx.shadowColor = `rgba(${c.r},${c.g},${c.b},${alpha * 0.4})`;
                    ctx.fillStyle = `rgba(${c.r},${c.g},${c.b},${alpha})`;
                    ctx.fillRect(this.x - s/2, this.y - s/2, s, s);

                    if (this.hasLabel && alpha > 0.4) {
                        this.drawLabel(s, alpha, false);
                    }
                    return;
                }

                if (this.type === 'TRAITOR') {
                    let alpha = readabilityAlpha; 
                    const s = this.size * this.activeScale;
                    const pulse = Math.sin(time * 0.004 + this.pulsePhase); 
                    const pT = (pulse + 1) / 2; 
                    const r = PALETTE.magenta.r + (PALETTE.red.r - PALETTE.magenta.r) * pT;
                    const g = PALETTE.magenta.g + (PALETTE.red.g - PALETTE.magenta.g) * pT;
                    const b = PALETTE.magenta.b + (PALETTE.red.b - PALETTE.magenta.b) * pT;

                    ctx.shadowBlur = 8 * this.activeScale; 
                    ctx.shadowColor = `rgba(${r},${g},${b}, 0.8)`;

                    ctx.globalCompositeOperation = 'screen';
                    ctx.fillStyle = `rgba(255, 0, 0, ${alpha * 0.7})`;
                    ctx.fillRect(this.x - s/2 - 1.5, this.y - s/2, s, s);
                    ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.7})`;
                    ctx.fillRect(this.x - s/2 + 1.5, this.y - s/2, s, s);
                    
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.fillStyle = `rgba(${r},${g},${b}, ${alpha})`;
                    ctx.fillRect(this.x - s/2, this.y - s/2, s, s);

                    this.drawLabel(s, alpha, true);
                }
            }

            drawLabel(nodeSize, alpha, isTraitor) {
                const labelX = this.x + nodeSize + 6;
                const labelY = this.y + 3;
                
                // --- FONT FIX: STRICT MONOSPACE FOR DATA ---
                ctx.font = '10px "Consolas", "Monaco", monospace';
                
                const labelText = isTraitor ? `[TRAITOR ${this.id}]` : `[SUBJECT ${this.id}]`;
                
                if (isTraitor) {
                    ctx.shadowBlur = 4; 
                    ctx.shadowColor = `rgba(${PALETTE.magenta.r}, ${PALETTE.magenta.g}, ${PALETTE.magenta.b}, 0.6)`;
                    ctx.fillStyle = `rgba(${PALETTE.magenta.r},${PALETTE.magenta.g},${PALETTE.magenta.b}, 1.0)`;
                } else {
                    ctx.shadowBlur = 4; 
                    ctx.shadowColor = `rgba(${PALETTE.cyan.r}, ${PALETTE.cyan.g}, ${PALETTE.cyan.b}, 0.4)`;
                    ctx.fillStyle = `rgba(${PALETTE.white.r},${PALETTE.white.g},${PALETTE.white.b}, ${alpha})`;
                }
                
                ctx.fillText(labelText, labelX, labelY);
                ctx.shadowBlur = 0; 
            }
        }

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            nodes = [];
            for (let i = 0; i < CONFIG.lattice.nodeCount; i++) {
                nodes.push(new Node(i));
            }
            nodes.sort((a, b) => a.depth - b.depth);
        }

        let startTime = Date.now();

        function animate() {
            const time = Date.now() - startTime;
            
            drawGrid(); 
            nodes.forEach(node => node.update(time));

            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.lineWidth = 1; 
            
            for (let i = 0; i < nodes.length; i++) {
                const a = nodes[i];
                if (a.type === 'SIGIL') continue; 

                let connections = 0;
                for (let j = i + 1; j < nodes.length; j++) {
                    const b = nodes[j];
                    if (b.type === 'SIGIL') continue;

                    const dx = a.x - b.x;
                    const dy = a.y - b.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < CONFIG.lattice.connectionDist) {
                        connections++;
                        let opacity = 1 - (dist / CONFIG.lattice.connectionDist);
                        opacity *= 0.25; 
                        
                        const midX = (a.x + b.x) / 2;
                        const midY = (a.y + b.y) / 2;
                        const mouseDist = Math.hypot(midX - mouse.x, midY - mouse.y);
                        if (mouseDist < CONFIG.lattice.mouseRadius) opacity += 0.15;

                        const centerDist = Math.hypot(midX - (width/2), midY - (height/2));
                        if (centerDist < CONFIG.lattice.centerSafeZone) opacity *= 0.3; 

                        if (a.type === 'TRAITOR' || b.type === 'TRAITOR') {
                            ctx.strokeStyle = `rgba(${PALETTE.magenta.r}, ${PALETTE.magenta.g}, ${PALETTE.magenta.b}, ${opacity * 1.5})`;
                        } else {
                            ctx.strokeStyle = `rgba(${PALETTE.neutral}, ${opacity})`;
                        }

                        ctx.beginPath();
                        ctx.moveTo(a.x, a.y);
                        ctx.lineTo(b.x, b.y);
                        ctx.stroke();
                        
                        if (connections > 3) break; 
                    }
                }
            }

            nodes.forEach(node => node.draw(time));
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', init);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        window.addEventListener('mouseout', () => {
            mouse.x = -5000;
            mouse.y = -5000;
        });

        init();
        animate();
    </script>
</body>
</html>
